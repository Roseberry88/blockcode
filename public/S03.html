<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>코딩스타트: 블록 코딩 환경</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/blockly/9.3.0/blockly_compressed.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/blockly/9.3.0/blocks_compressed.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/blockly/9.3.0/javascript_compressed.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/blockly/9.3.0/python_compressed.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/blockly/9.3.0/msg/ko.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f5f5f5;
        }

        .main-container {
            display: flex;
            flex-direction: column;
            width: 100%;
            max-width: 1200px;
            height: 100vh;
            margin: 0 auto;
            background-color: white;
            border: 1px solid #ddd;
            border-radius: 10px;
            overflow: hidden;
        }

        .header {
            height: 60px;
            background: linear-gradient(135deg, #4285f4, #2a5298);
            display: flex;
            align-items: center;
            padding: 0 20px;
            border-radius: 10px 10px 0 0;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .header-title {
            color: white;
            font-weight: bold;
            font-size: 22px;
            margin-right: 20px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .header-title:hover {
            transform: scale(1.05);
        }

        .back-button {
            background-color: rgba(255,255,255,0.1);
            margin-right: auto;
        }

        .project-name {
            height: 30px;
            width: 200px;
            border-radius: 5px;
            border: none;
            padding: 0 10px;
            margin-right: 20px;
        }

        .header-button {
            height: 30px;
            padding: 0 15px;
            border-radius: 15px;
            border: none;
            background-color: rgba(255,255,255,0.2);
            color: white;
            font-size: 14px;
            margin-left: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .header-button:hover {
            background-color: rgba(255,255,255,0.3);
            transform: translateY(-2px);
        }

        .content {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

        .left-panel {
            width: 280px;
            border-right: 1px solid #ddd;
            background-color: #f8f9fa;
            display: flex;
            flex-direction: column;
        }

        .category-tabs {
            height: 40px;
            background-color: #eee;
            display: flex;
            align-items: center;
            padding: 0 10px;
        }

        .category-tab {
            width: 40px;
            height: 30px;
            border-radius: 5px;
            margin-right: 10px;
            border: none;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .category-tab.active {
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
            transform: translateY(-1px);
        }

        .search-block {
            margin: 10px;
            position: relative;
        }

        .search-input {
            width: 100%;
            height: 30px;
            border-radius: 15px;
            border: 1px solid #ddd;
            padding: 0 15px;
            font-size: 12px;
            box-sizing: border-box;
        }

        .category-title {
            height: 30px;
            display: flex;
            align-items: center;
            padding: 0 15px;
            font-weight: bold;
            color: white;
            font-size: 14px;
        }

        .blocks-container {
            overflow-y: auto;
            flex: 1;
        }

        .block-item {
            margin: 8px 15px;
            padding: 10px;
            color: white;
            border-radius: 8px;
            cursor: grab;
            user-select: none;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.2s ease;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .block-item:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }

        .block-item:active {
            cursor: grabbing;
        }

        .category-control {
            background-color: #fbbc05;
        }

        .category-movement {
            background-color: #4285f4;
        }

        .category-variables {
            background-color: #ea4335;
        }

        .category-logic {
            background-color: #34a853;
        }

        .center-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        .workspace-controls {
            height: 40px;
            background-color: #eee;
            display: flex;
            align-items: center;
            padding: 0 20px;
            justify-content: space-between;
        }

        .workspace-title {
            font-weight: bold;
            font-size: 16px;
            color: #333;
        }

        .minimap {
            width: 100px;
            height: 30px;
            background-color: #f1f3f4;
            border: 1px solid #ddd;
            border-radius: 5px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            color: #666;
        }

        #blocklyDiv {
            flex: 1;
            border-top: 1px solid #ddd;
            min-height: 400px;
        }

        .status-bar {
            height: 30px;
            background-color: #f8f9fa;
            display: flex;
            align-items: center;
            padding: 0 20px;
            font-size: 12px;
            color: #666;
            border-top: 1px solid #ddd;
        }

        .right-panel {
            width: 280px;
            border-left: 1px solid #ddd;
            display: flex;
            flex-direction: column;
        }

        .result-header {
            height: 40px;
            background-color: #eee;
            display: flex;
            align-items: center;
            padding: 0 20px;
            justify-content: space-between;
        }

        .result-title {
            font-weight: bold;
            font-size: 16px;
            color: #333;
        }

        .control-buttons {
            display: flex;
        }

        .control-button {
            width: 30px;
            height: 30px;
            border-radius: 15px;
            border: none;
            margin-left: 10px;
            color: white;
            font-weight: bold;
            font-size: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .control-button:hover {
            transform: scale(1.1);
        }

        .run-button {
            background-color: #4285f4;
        }

        .stop-button {
            background-color: #fbbc05;
        }

        .reset-button {
            background-color: #34a853;
        }

        .result-canvas {
            height: 200px;
            background-color: #f8f9fa;
            border: 1px solid #ddd;
            margin: 10px;
            position: relative;
            overflow: hidden;
        }

        .character {
            position: absolute;
            width: 0;
            height: 0;
            border-left: 10px solid transparent;
            border-right: 10px solid transparent;
            border-bottom: 20px solid #3b78e7;
            transform-origin: 50% 100%;
            transition: all 0.1s ease;
        }

        .console {
            height: 150px;
            background-color: #f1f1f1;
            border: 1px solid #ddd;
            margin: 10px;
            padding: 10px;
            overflow-y: auto;
            font-size: 12px;
            font-family: monospace;
        }

        .console-line {
            margin: 2px 0;
            color: #333;
        }

        .variable-monitor {
            flex: 1;
            background-color: #fff;
            border: 1px solid #ddd;
            margin: 10px;
            padding: 10px;
            overflow-y: auto;
        }

        .variable-monitor-title {
            font-weight: bold;
            font-size: 14px;
            color: #333;
            margin-bottom: 10px;
        }

        .variable-item {
            height: 30px;
            background-color: #f8f9fa;
            border: 1px solid #ddd;
            margin-bottom: 5px;
            padding: 0 10px;
            display: flex;
            align-items: center;
            font-size: 12px;
            border-radius: 3px;
        }

        .code-panel {
            height: 200px;
            background-color: #292d3e;
            border: 1px solid #1e2132;
            display: flex;
            flex-direction: column;
        }

        .code-header {
            height: 40px;
            background-color: #1e2132;
            display: flex;
            align-items: center;
            padding: 0 20px;
            justify-content: space-between;
        }

        .code-title {
            font-weight: bold;
            font-size: 16px;
            color: white;
        }

        .language-buttons {
            display: flex;
        }

        .language-button {
            width: 80px;
            height: 30px;
            border-radius: 5px;
            margin-left: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .active-language {
            background-color: #3b78e7;
            border: none;
        }

        .inactive-language {
            background-color: #292d3e;
            border: 1px solid #3b78e7;
        }

        .inactive-language:hover {
            background-color: #3b78e7;
        }

        .code-content {
            flex: 1;
            padding: 15px;
            overflow-y: auto;
            color: #a6accd;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            white-space: pre-wrap;
            line-height: 1.4;
        }

        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 9999;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
        }

        .loading-overlay.active {
            opacity: 1;
            visibility: visible;
        }

        .loading-spinner {
            width: 50px;
            height: 50px;
            border: 4px solid rgba(255,255,255,0.3);
            border-top: 4px solid #fff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .navigation-notification {
            position: fixed;
            top: 100px;
            right: 30px;
            background: linear-gradient(135deg, #4CAF50, #45a049);
            color: white;
            padding: 15px 25px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            transform: translateX(400px);
            transition: transform 0.3s ease;
            z-index: 1000;
            font-family: Arial, sans-serif;
        }

        .error-message {
            color: #d32f2f;
            background-color: #ffebee;
            border: 1px solid #ffcdd2;
            padding: 10px;
            border-radius: 4px;
            margin: 10px;
            font-size: 12px;
        }

        #toolbox {
            display: none;
        }
    </style>
</head>

<body>
    <!-- 로딩 오버레이 -->
    <div class="loading-overlay" id="loadingOverlay">
        <div class="loading-spinner"></div>
    </div>

    <div class="main-container">
        <div class="header">
            <div class="header-title" id="logoTitle">🚀 코딩스타트: 블록 코딩</div>
            <button class="header-button back-button" id="backButton">← 대시보드</button>
            <input type="text" class="project-name" value="내 프로젝트" id="projectName">
            <div style="flex-grow: 1;"></div>
            <button class="header-button" id="runButton">실행</button>
            <button class="header-button" id="saveButton">저장</button>
            <button class="header-button" id="loadButton">불러오기</button>
        </div>
        
        <div class="content">
            <div class="left-panel">
                <div class="category-tabs">
                    <button class="category-tab category-control" data-category="control" title="제어">🎯</button>
                    <button class="category-tab category-movement" data-category="movement" title="움직임">🚀</button>
                    <button class="category-tab category-variables" data-category="variables" title="변수">📦</button>
                    <button class="category-tab category-logic" data-category="logic" title="논리">🧠</button>
                </div>
                <div class="search-block">
                    <input type="text" class="search-input" placeholder="블록 검색..." id="blockSearch">
                </div>
                <div class="blocks-container" id="blocksContainer">
                    <!-- 블록들이 여기에 동적으로 생성됩니다 -->
                </div>
                
                <!-- 숨겨진 툴박스 -->
                <xml id="toolboxXML" style="display: none;">
                    <category name="제어" colour="#fbbc05">
                        <block type="start"></block>
                        <block type="controls_repeat_ext">
                            <value name="TIMES">
                                <shadow type="math_number">
                                    <field name="NUM">10</field>
                                </shadow>
                            </value>
                        </block>
                        <block type="controls_if"></block>
                        <block type="wait">
                            <value name="TIME">
                                <shadow type="math_number">
                                    <field name="NUM">1</field>
                                </shadow>
                            </value>
                        </block>
                    </category>
                    <category name="움직임" colour="#4285f4">
                        <block type="move_forward">
                            <value name="DISTANCE">
                                <shadow type="math_number">
                                    <field name="NUM">10</field>
                                </shadow>
                            </value>
                        </block>
                        <block type="turn_right">
                            <value name="ANGLE">
                                <shadow type="math_number">
                                    <field name="NUM">90</field>
                                </shadow>
                            </value>
                        </block>
                        <block type="turn_left">
                            <value name="ANGLE">
                                <shadow type="math_number">
                                    <field name="NUM">90</field>
                                </shadow>
                            </value>
                        </block>
                    </category>
                    <category name="논리" colour="#34a853">
                        <block type="logic_compare"></block>
                        <block type="logic_operation"></block>
                        <block type="logic_boolean"></block>
                    </category>
                    <category name="변수" colour="#ea4335" custom="VARIABLE"></category>
                    <category name="수학" colour="#9966FF">
                        <block type="math_number">
                            <field name="NUM">1</field>
                        </block>
                        <block type="math_arithmetic">
                            <value name="A">
                                <shadow type="math_number">
                                    <field name="NUM">1</field>
                                </shadow>
                            </value>
                            <value name="B">
                                <shadow type="math_number">
                                    <field name="NUM">1</field>
                                </shadow>
                            </value>
                        </block>
                        <block type="math_number_property">
                            <value name="NUMBER_TO_CHECK">
                                <shadow type="math_number">
                                    <field name="NUM">0</field>
                                </shadow>
                            </value>
                        </block>
                    </category>
                </xml>
            </div>
            
            <div class="center-panel">
                <div class="workspace-controls">
                    <div class="workspace-title">코드 작성 영역</div>
                    <div class="minimap">블록 작업공간</div>
                </div>
                <div id="blocklyDiv"></div>
                <div class="status-bar">
                    <span id="blockCount">블록 수: 0</span> | 
                    <span id="lastSaved">마지막 저장: --:-- --</span> | 
                    <span id="executionStatus">준비됨</span>
                </div>
            </div>
            
            <div class="right-panel">
                <div class="result-header">
                    <div class="result-title">실행 결과</div>
                    <div class="control-buttons">
                        <button class="control-button run-button" id="runButtonSmall" title="실행">▶</button>
                        <button class="control-button stop-button" id="stopButton" title="정지">■</button>
                        <button class="control-button reset-button" id="resetButton" title="리셋">↻</button>
                    </div>
                </div>
                
                <div class="result-canvas" id="canvas">
                    <div class="character" id="character"></div>
                </div>
                
                <div class="console" id="console">
                    <div class="console-line">> 프로그램 시작 준비</div>
                </div>
                
                <div class="variable-monitor">
                    <div class="variable-monitor-title">변수 모니터</div>
                    <div id="variables"></div>
                </div>
            </div>
        </div>
        
        <div class="code-panel">
            <div class="code-header">
                <div class="code-title">생성된 코드 (Python)</div>
                <div class="language-buttons">
                    <div class="language-button active-language" id="pythonButton">Python</div>
                    <div class="language-button inactive-language" id="javascriptButton">JavaScript</div>
                    <div class="language-button inactive-language" id="cppButton">C++</div>
                </div>
            </div>
            <div class="code-content" id="codeContent"># 블록을 연결하면 여기에 코드가 생성됩니다</div>
        </div>
    </div>

    <script>
        // 전역 변수 선언
        let workspace = null;
        let character = null;
        let x = 130;
        let y = 130;
        let angle = 0;
        let variables = {};
        let isRunning = false;
        let shouldStop = false;
        let navigationManager = null;

        // 통합 네비게이션 시스템
        class NavigationManager {
            constructor() {
                this.currentUser = null;
                this.routes = {
                    'dashboard': '/dashboard',
                    'block-coding': '/block-coding',
                    'algorithm': '/algorithm',
                    'assignments': '/assignments',
                    'progress': '/progress',
                    'teacher-dashboard': '/teacher-dashboard',
                    'create-assignment': '/create-assignment',
                    'review-submissions': '/review-submissions',
                    'student-analytics': '/student-analytics',
                    'student-management': '/student-management',
                    'login': '/login'
                };
                this.init();
            }

            init() {
                this.loadUserInfo();
                this.setupEventListeners();
            }

            loadUserInfo() {
                const token = localStorage.getItem('authToken');
                const userJSON = localStorage.getItem('user');

                if (!token || !userJSON) {
                    this.redirectToLogin();
                    return false;
                }

                try {
                    this.currentUser = JSON.parse(userJSON);
                    return true;
                } catch (error) {
                    console.error('사용자 정보 파싱 오류:', error);
                    this.clearAuthAndRedirect();
                    return false;
                }
            }

            setupEventListeners() {
                const logoTitle = document.getElementById('logoTitle');
                if (logoTitle) {
                    logoTitle.addEventListener('click', () => {
                        this.navigateToDashboard();
                    });
                }

                const backButton = document.getElementById('backButton');
                if (backButton) {
                    backButton.addEventListener('click', () => {
                        this.navigateToDashboard();
                    });
                }
            }

            navigateToDashboard() {
                if (this.currentUser && (this.currentUser.role === 'professor' || this.currentUser.role === 'admin')) {
                    this.navigateTo('teacher-dashboard');
                } else {
                    this.navigateTo('dashboard');
                }
            }

            navigateTo(routeName) {
                if (this.routes[routeName]) {
                    this.showLoading();
                    setTimeout(() => {
                        window.location.href = this.routes[routeName];
                    }, 300);
                } else {
                    console.error(`Route not found: ${routeName}`);
                }
            }

            redirectToLogin() {
                this.showNotification('로그인이 필요합니다.', 'error');
                setTimeout(() => {
                    window.location.href = this.routes.login;
                }, 1500);
            }

            clearAuthAndRedirect() {
                localStorage.clear();
                this.redirectToLogin();
            }

            showLoading() {
                const loadingOverlay = document.getElementById('loadingOverlay');
                if (loadingOverlay) {
                    loadingOverlay.classList.add('active');
                }
            }

            hideLoading() {
                const loadingOverlay = document.getElementById('loadingOverlay');
                if (loadingOverlay) {
                    loadingOverlay.classList.remove('active');
                }
            }

            showNotification(message, type = 'success') {
                const existingNotification = document.getElementById('navigationNotification');
                if (existingNotification) {
                    existingNotification.remove();
                }

                const notification = document.createElement('div');
                notification.id = 'navigationNotification';
                notification.className = 'navigation-notification';
                notification.textContent = message;

                const backgroundColor = type === 'error'
                    ? 'linear-gradient(135deg, #f44336, #d32f2f)'
                    : 'linear-gradient(135deg, #4CAF50, #45a049)';

                notification.style.background = backgroundColor;
                document.body.appendChild(notification);

                setTimeout(() => {
                    notification.style.transform = 'translateX(0)';
                }, 100);

                setTimeout(() => {
                    notification.style.transform = 'translateX(400px)';
                    setTimeout(() => {
                        if (notification.parentNode) {
                            notification.parentNode.removeChild(notification);
                        }
                    }, 300);
                }, 3000);
            }
        }

        // 페이지 로드 시 초기화 (완전히 새로운 접근)
        document.addEventListener('DOMContentLoaded', function() {
            console.log('=== 페이지 로드 시작 ===');
            
            // 네비게이션 매니저 초기화
            navigationManager = new NavigationManager();
            if (navigationManager) {
                navigationManager.hideLoading();
            }

            // 캐릭터 요소 초기화
            character = document.getElementById('character');
            resetCharacter();

            // 즉시 실행: 커스텀 블록과 코드 생성기 정의
            console.log('커스텀 블록 및 코드 생성기 정의...');
            defineCustomBlocks();
            defineCodeGenerators();

            // 잠시 후 Blockly 워크스페이스 초기화
            setTimeout(() => {
                console.log('Blockly 워크스페이스 초기화 시작...');
                initializeBlocklyWorkspace();
            }, 100);

            // 블록 팔레트 생성
            setTimeout(() => {
                console.log('블록 팔레트 생성...');
                createBlockPalette();
            }, 200);

            // 이벤트 리스너 설정
            setTimeout(() => {
                console.log('이벤트 리스너 설정...');
                setupEventListeners();
                updateCode();
                updateBlockCount();
                updateVariableDisplay();
                console.log('=== 초기화 완료 ===');
            }, 300);
        });

        // 간단한 Blockly 워크스페이스 초기화
        function initializeBlocklyWorkspace() {
            try {
                console.log('Blockly 워크스페이스 초기화 시작...');
                
                // 기존 워크스페이스 정리
                if (workspace) {
                    console.log('기존 워크스페이스 제거...');
                    workspace.dispose();
                }

                // blocklyDiv 요소 확인
                const blocklyDiv = document.getElementById('blocklyDiv');
                if (!blocklyDiv) {
                    console.error('❌ blocklyDiv 요소를 찾을 수 없습니다.');
                    return;
                }

                console.log('blocklyDiv 요소 발견:', blocklyDiv);

                // 매우 간단한 워크스페이스 생성
                workspace = Blockly.inject('blocklyDiv', {
                    grid: { spacing: 20, length: 3, colour: '#ccc' },
                    zoom: { controls: true, wheel: true, startScale: 1.0 },
                    trashcan: true,
                    scrollbars: true
                });

                if (workspace) {
                    console.log('✅ Blockly 워크스페이스 생성 성공!');
                    
                    // 워크스페이스 크기 조정
                    Blockly.svgResize(workspace);
                    
                    // 변경 이벤트 리스너 추가
                    workspace.addChangeListener(function(event) {
                        if (event.type === Blockly.Events.BLOCK_CREATE ||
                            event.type === Blockly.Events.BLOCK_DELETE ||
                            event.type === Blockly.Events.BLOCK_CHANGE) {
                            console.log('워크스페이스 변경:', event.type);
                            updateCode();
                            updateBlockCount();
                        }
                    });

                    // 테스트 블록 추가
                    setTimeout(() => {
                        addTestBlock();
                    }, 500);

                } else {
                    console.error('❌ Blockly 워크스페이스 생성 실패');
                }

            } catch (error) {
                console.error('❌ Blockly 초기화 오류:', error);
            }
        }

        // 테스트 블록 추가
        function addTestBlock() {
            if (!workspace) {
                console.error('워크스페이스가 없습니다.');
                return;
            }

            try {
                console.log('테스트 블록 추가...');
                
                // 시작 블록 생성
                const startBlock = workspace.newBlock('start');
                startBlock.moveBy(100, 100);
                startBlock.initSvg();
                startBlock.render();
                
                // 이동 블록 생성
                const moveBlock = workspace.newBlock('move_forward');
                moveBlock.moveBy(100, 150);
                moveBlock.initSvg();
                moveBlock.render();
                
                // 숫자 블록 생성 및 연결
                const numberBlock = workspace.newBlock('math_number');
                numberBlock.setFieldValue('10', 'NUM');
                numberBlock.initSvg();
                numberBlock.render();
                numberBlock.moveBy(200, 150);
                
                // 블록 연결
                if (moveBlock.getInput('DISTANCE') && numberBlock.outputConnection) {
                    moveBlock.getInput('DISTANCE').connection.connect(numberBlock.outputConnection);
                }
                
                console.log('✅ 테스트 블록 추가 완료');
                updateCode();
                updateBlockCount();
                
            } catch (error) {
                console.error('❌ 테스트 블록 추가 실패:', error);
            }
        }

        // 블록 팔레트 생성 (단순화)
        function createBlockPalette() {
            console.log('블록 팔레트 생성...');
            
            const categories = {
                control: {
                    name: '움직임',
                    color: '#4285f4',
                    blocks: [
                        { name: '🚀 시작하기', type: 'start' },
                        { name: '🔼 앞으로 이동', type: 'move_forward' },
                        { name: '➡️ 오른쪽 회전', type: 'turn_right' },
                        { name: '⬅️ 왼쪽 회전', type: 'turn_left' },
                        { name: '⏱️ 기다리기', type: 'wait' },
                        { name: '🔢 숫자', type: 'math_number' },
                        { name: '🔁 반복하기', type: 'controls_repeat_ext' }
                    ]
                }
            };

            // 기본 움직임 카테고리 표시
            displayBlocks(categories.control);

            // 탭 이벤트 설정
            const tabs = document.querySelectorAll('.category-tab');
            tabs.forEach(tab => {
                tab.addEventListener('click', () => {
                    tabs.forEach(t => t.classList.remove('active'));
                    tab.classList.add('active');
                    displayBlocks(categories.control);
                });
            });

            // 첫 번째 탭 활성화
            if (tabs.length > 0) {
                tabs[0].classList.add('active');
            }
        }

        // 블록 표시
        function displayBlocks(category) {
            const container = document.getElementById('blocksContainer');
            if (!container) return;

            container.innerHTML = `
                <div style="
                    height: 30px;
                    background-color: ${category.color};
                    color: white;
                    font-weight: bold;
                    display: flex;
                    align-items: center;
                    padding: 0 15px;
                    margin-bottom: 10px;
                ">
                    ${category.name}
                </div>
            `;

            category.blocks.forEach(block => {
                const blockEl = document.createElement('div');
                blockEl.innerHTML = `
                    <div style="
                        margin: 8px 15px;
                        padding: 12px;
                        background-color: ${category.color};
                        color: white;
                        border-radius: 8px;
                        cursor: pointer;
                        font-size: 14px;
                        font-weight: 500;
                        transition: all 0.2s ease;
                        border: 2px solid transparent;
                    " onmouseover="this.style.transform='scale(1.05)'; this.style.borderColor='white';" 
                       onmouseout="this.style.transform='scale(1)'; this.style.borderColor='transparent';"
                       onclick="addBlockToWorkspace('${block.type}')">
                        ${block.name}
                    </div>
                `;
                container.appendChild(blockEl);
            });
        }

        // 워크스페이스에 블록 추가 (단순화)
        function addBlockToWorkspace(blockType) {
            console.log('블록 추가 시도:', blockType);
            
            if (!workspace) {
                console.error('❌ 워크스페이스가 없습니다. 다시 초기화 시도...');
                initializeBlocklyWorkspace();
                return;
            }

            try {
                // 블록 생성
                const newBlock = workspace.newBlock(blockType);
                if (!newBlock) {
                    console.error('❌ 블록 생성 실패:', blockType);
                    return;
                }

                // 위치 설정
                const blocks = workspace.getAllBlocks();
                const x = 50 + (blocks.length * 30);
                const y = 50 + (blocks.length * 30);
                
                newBlock.moveBy(x, y);
                newBlock.initSvg();
                newBlock.render();

                // 기본값 설정
                setBlockDefaults(newBlock, blockType);

                console.log('✅ 블록 추가 성공:', blockType);
                updateCode();
                updateBlockCount();
                logToConsole(`블록 "${blockType}" 추가됨`);

            } catch (error) {
                console.error('❌ 블록 추가 오류:', error);
                logToConsole(`블록 추가 오류: ${error.message}`);
            }
        }

        // 블록 기본값 설정 (단순화)
        function setBlockDefaults(block, blockType) {
            if (!block || !workspace) return;

            try {
                switch (blockType) {
                    case 'move_forward':
                    case 'turn_right':
                    case 'turn_left':
                        const inputName = blockType === 'move_forward' ? 'DISTANCE' : 'ANGLE';
                        const defaultValue = blockType === 'move_forward' ? '10' : '90';
                        
                        if (block.getInput(inputName)) {
                            const numBlock = workspace.newBlock('math_number');
                            numBlock.setFieldValue(defaultValue, 'NUM');
                            numBlock.initSvg();
                            numBlock.render();
                            block.getInput(inputName).connection.connect(numBlock.outputConnection);
                        }
                        break;
                    case 'wait':
                        if (block.getInput('TIME')) {
                            const numBlock = workspace.newBlock('math_number');
                            numBlock.setFieldValue('1', 'NUM');
                            numBlock.initSvg();
                            numBlock.render();
                            block.getInput('TIME').connection.connect(numBlock.outputConnection);
                        }
                        break;
                    case 'controls_repeat_ext':
                        if (block.getInput('TIMES')) {
                            const numBlock = workspace.newBlock('math_number');
                            numBlock.setFieldValue('10', 'NUM');
                            numBlock.initSvg();
                            numBlock.render();
                            block.getInput('TIMES').connection.connect(numBlock.outputConnection);
                        }
                        break;
                }
            } catch (error) {
                console.error('기본값 설정 오류:', error);
            }
        }

        // 기존 복잡한 함수들 제거하고 단순화된 버전으로 대체

        // 블록 표시 함수 (클릭 이벤트 강화)
        function showBlocks(category) {
            console.log('블록 표시:', category.name);
            
            const container = document.getElementById('blocksContainer');
            if (!container) {
                console.error('blocksContainer를 찾을 수 없습니다.');
                return;
            }

            // 컨테이너 초기화
            container.innerHTML = '';

            // 카테고리 제목
            const title = document.createElement('div');
            title.innerHTML = `
                <div style="
                    height: 30px;
                    background-color: ${category.color};
                    color: white;
                    font-weight: bold;
                    font-size: 14px;
                    display: flex;
                    align-items: center;
                    padding: 0 15px;
                    margin-bottom: 5px;
                ">
                    ${category.name}
                </div>
            `;
            container.appendChild(title);

            // 블록들 추가
            category.blocks.forEach(block => {
                const blockElement = document.createElement('div');
                blockElement.innerHTML = `
                    <div class="simple-block" data-block-type="${block.type}" style="
                        margin: 8px 15px;
                        padding: 12px;
                        background-color: ${category.color};
                        color: white;
                        border-radius: 8px;
                        cursor: pointer;
                        user-select: none;
                        font-size: 14px;
                        font-weight: 500;
                        transition: all 0.2s ease;
                        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
                        border: 2px solid transparent;
                    ">
                        ${block.name}
                    </div>
                `;
                
                const blockDiv = blockElement.querySelector('.simple-block');
                
                // 호버 효과
                blockDiv.addEventListener('mouseenter', () => {
                    blockDiv.style.transform = 'translateY(-2px)';
                    blockDiv.style.boxShadow = '0 4px 8px rgba(0,0,0,0.2)';
                    blockDiv.style.borderColor = 'rgba(255,255,255,0.3)';
                });

                blockDiv.addEventListener('mouseleave', () => {
                    blockDiv.style.transform = 'translateY(0)';
                    blockDiv.style.boxShadow = '0 2px 4px rgba(0,0,0,0.1)';
                    blockDiv.style.borderColor = 'transparent';
                });

                // 클릭 이벤트 (강화된 버전)
                blockDiv.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    console.log('블록 클릭됨:', block.type);
                    
                    // 클릭 피드백
                    blockDiv.style.transform = 'scale(0.95)';
                    blockDiv.style.backgroundColor = 'rgba(255,255,255,0.2)';
                    
                    setTimeout(() => {
                        blockDiv.style.transform = 'translateY(0)';
                        blockDiv.style.backgroundColor = category.color;
                        
                        // 블록 추가 실행
                        addBlockToWorkspace(block.type);
                    }, 150);
                });

                // 더블클릭 방지
                blockDiv.addEventListener('dblclick', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                });

                container.appendChild(blockElement);
            });

            console.log(`${category.blocks.length}개의 블록이 표시되었습니다.`);
        }

        // 워크스페이스에 블록 추가
        function addBlockToWorkspace(blockType) {
            console.log('워크스페이스에 블록 추가 시도:', blockType);
            
            if (!workspace) {
                console.error('❌ 워크스페이스가 초기화되지 않았습니다.');
                // 워크스페이스 재초기화 시도
                setTimeout(() => {
                    initializeBlockly();
                }, 100);
                return;
            }

            try {
                // 블록 생성
                const newBlock = workspace.newBlock(blockType);
                
                if (!newBlock) {
                    console.error('❌ 블록 생성 실패:', blockType);
                    return;
                }

                // 위치 설정 (겹치지 않도록)
                const existingBlocks = workspace.getAllBlocks();
                const x = 50 + (existingBlocks.length * 20);
                const y = 50 + (existingBlocks.length * 20);
                
                console.log('블록 위치 설정:', x, y);
                
                // 블록 초기화 및 렌더링
                newBlock.moveBy(x, y);
                newBlock.initSvg();
                newBlock.render();

                // 기본값 설정
                setupBlockDefaults(newBlock, blockType);

                // 변경 이벤트 발생
                Blockly.Events.fire(new Blockly.Events.BlockCreate(newBlock));
                
                console.log('✅ 블록 추가 성공:', blockType);
                
                // 즉시 코드 업데이트
                updateCode();
                updateBlockCount();
                
                // 성공 메시지
                logToConsole(`블록 "${blockType}"이 추가되었습니다.`);

            } catch (error) {
                console.error('❌ 블록 추가 오류:', error);
                logToConsole(`블록 추가 중 오류 발생: ${error.message}`);
            }
        }

        // 블록 기본값 설정 (개선된 버전)
        function setupBlockDefaults(block, blockType) {
            if (!block || !workspace) return;
            
            try {
                console.log('블록 기본값 설정:', blockType);
                
                switch (blockType) {
                    case 'move_forward':
                        if (block.getInput('DISTANCE') && block.getInput('DISTANCE').connection) {
                            const numberBlock = workspace.newBlock('math_number');
                            numberBlock.setFieldValue('10', 'NUM');
                            numberBlock.initSvg();
                            numberBlock.render();
                            block.getInput('DISTANCE').connection.connect(numberBlock.outputConnection);
                        }
                        break;
                    case 'turn_right':
                    case 'turn_left':
                        if (block.getInput('ANGLE') && block.getInput('ANGLE').connection) {
                            const numberBlock = workspace.newBlock('math_number');
                            numberBlock.setFieldValue('90', 'NUM');
                            numberBlock.initSvg();
                            numberBlock.render();
                            block.getInput('ANGLE').connection.connect(numberBlock.outputConnection);
                        }
                        break;
                    case 'wait':
                        if (block.getInput('TIME') && block.getInput('TIME').connection) {
                            const numberBlock = workspace.newBlock('math_number');
                            numberBlock.setFieldValue('1', 'NUM');
                            numberBlock.initSvg();
                            numberBlock.render();
                            block.getInput('TIME').connection.connect(numberBlock.outputConnection);
                        }
                        break;
                    case 'controls_repeat_ext':
                        if (block.getInput('TIMES') && block.getInput('TIMES').connection) {
                            const numberBlock = workspace.newBlock('math_number');
                            numberBlock.setFieldValue('10', 'NUM');
                            numberBlock.initSvg();
                            numberBlock.render();
                            block.getInput('TIMES').connection.connect(numberBlock.outputConnection);
                        }
                        break;
                    case 'variables_set':
                        // 변수 블록의 경우 변수 생성
                        if (workspace.getAllVariables().length === 0) {
                            workspace.createVariable('변수1');
                        }
                        break;
                    case 'math_change':
                        // 변수 변경 블록의 경우 변수 생성
                        if (workspace.getAllVariables().length === 0) {
                            workspace.createVariable('변수1');
                        }
                        break;
                }
                
                console.log('블록 기본값 설정 완료:', blockType);
            } catch (error) {
                console.error('블록 기본값 설정 오류:', error);
            }
        }

        // 블록 검색
        function searchAllBlocks(searchTerm, categories) {
            console.log('블록 검색:', searchTerm);
            
            const container = document.getElementById('blocksContainer');
            if (!container) return;

            container.innerHTML = '';

            // 검색 결과 제목
            const title = document.createElement('div');
            title.innerHTML = `
                <div style="
                    height: 30px;
                    background-color: #666;
                    color: white;
                    font-weight: bold;
                    font-size: 14px;
                    display: flex;
                    align-items: center;
                    padding: 0 15px;
                    margin-bottom: 5px;
                ">
                    "${searchTerm}" 검색 결과
                </div>
            `;
            container.appendChild(title);

            let foundBlocks = [];
            
            // 모든 카테고리에서 검색
            Object.values(categories).forEach(category => {
                category.blocks.forEach(block => {
                    if (block.name.toLowerCase().includes(searchTerm)) {
                        foundBlocks.push({ ...block, color: category.color });
                    }
                });
            });

            if (foundBlocks.length === 0) {
                const noResults = document.createElement('div');
                noResults.innerHTML = `
                    <div style="
                        padding: 20px;
                        text-align: center;
                        color: #666;
                        font-size: 14px;
                    ">
                        검색 결과가 없습니다.
                    </div>
                `;
                container.appendChild(noResults);
            } else {
                foundBlocks.forEach(block => {
                    const blockElement = document.createElement('div');
                    blockElement.innerHTML = `
                        <div class="simple-block" data-block-type="${block.type}" style="
                            margin: 8px 15px;
                            padding: 12px;
                            background-color: ${block.color};
                            color: white;
                            border-radius: 8px;
                            cursor: pointer;
                            user-select: none;
                            font-size: 14px;
                            font-weight: 500;
                            transition: all 0.2s ease;
                            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
                        ">
                            ${block.name}
                        </div>
                    `;
                    
                    const blockDiv = blockElement.querySelector('.simple-block');
                    
                    // 호버 효과
                    blockDiv.addEventListener('mouseenter', () => {
                        blockDiv.style.transform = 'translateY(-2px)';
                        blockDiv.style.boxShadow = '0 4px 8px rgba(0,0,0,0.2)';
                    });

                    blockDiv.addEventListener('mouseleave', () => {
                        blockDiv.style.transform = 'translateY(0)';
                        blockDiv.style.boxShadow = '0 2px 4px rgba(0,0,0,0.1)';
                    });

                    // 클릭 이벤트
                    blockDiv.addEventListener('click', () => {
                        addBlockToWorkspace(block.type);
                    });

                    container.appendChild(blockElement);
                });
            }

            console.log(`검색 결과: ${foundBlocks.length}개 블록`);
        }

        // 커스텀 블록 정의
        function defineCustomBlocks() {
            // 시작 블록
            Blockly.Blocks['start'] = {
                init: function() {
                    this.appendDummyInput()
                        .appendField("🚀 시작하기");
                    this.setNextStatement(true, null);
                    this.setColour(120);
                    this.setTooltip("프로그램이 시작될 때 실행됩니다.");
                }
            };

            // 앞으로 이동 블록
            Blockly.Blocks['move_forward'] = {
                init: function() {
                    this.appendValueInput("DISTANCE")
                        .setCheck("Number")
                        .appendField("🔼 앞으로");
                    this.appendDummyInput()
                        .appendField("만큼 이동");
                    this.setPreviousStatement(true, null);
                    this.setNextStatement(true, null);
                    this.setColour(210);
                    this.setTooltip("캐릭터를 앞으로 이동시킵니다.");
                }
            };

            // 오른쪽 회전 블록
            Blockly.Blocks['turn_right'] = {
                init: function() {
                    this.appendValueInput("ANGLE")
                        .setCheck("Number")
                        .appendField("➡️ 오른쪽으로");
                    this.appendDummyInput()
                        .appendField("도 회전");
                    this.setPreviousStatement(true, null);
                    this.setNextStatement(true, null);
                    this.setColour(210);
                    this.setTooltip("캐릭터를 오른쪽으로 회전시킵니다.");
                }
            };

            // 왼쪽 회전 블록
            Blockly.Blocks['turn_left'] = {
                init: function() {
                    this.appendValueInput("ANGLE")
                        .setCheck("Number")
                        .appendField("⬅️ 왼쪽으로");
                    this.appendDummyInput()
                        .appendField("도 회전");
                    this.setPreviousStatement(true, null);
                    this.setNextStatement(true, null);
                    this.setColour(210);
                    this.setTooltip("캐릭터를 왼쪽으로 회전시킵니다.");
                }
            };

            // 대기 블록
            Blockly.Blocks['wait'] = {
                init: function() {
                    this.appendValueInput("TIME")
                        .setCheck("Number")
                        .appendField("⏱️ 대기");
                    this.appendDummyInput()
                        .appendField("초");
                    this.setPreviousStatement(true, null);
                    this.setNextStatement(true, null);
                    this.setColour(290);
                    this.setTooltip("지정된 시간(초) 동안 기다립니다.");
                }
            };
        }

        // 코드 생성기 정의
        function defineCodeGenerators() {
            // JavaScript 코드 생성기
            Blockly.JavaScript['start'] = function(block) {
                return '// 프로그램 시작\n';
            };

            Blockly.JavaScript['move_forward'] = function(block) {
                const distance = Blockly.JavaScript.valueToCode(block, 'DISTANCE', Blockly.JavaScript.ORDER_ATOMIC) || '10';
                return `await moveForward(${distance});\n`;
            };

            Blockly.JavaScript['turn_right'] = function(block) {
                const angle = Blockly.JavaScript.valueToCode(block, 'ANGLE', Blockly.JavaScript.ORDER_ATOMIC) || '90';
                return `await turnRight(${angle});\n`;
            };

            Blockly.JavaScript['turn_left'] = function(block) {
                const angle = Blockly.JavaScript.valueToCode(block, 'ANGLE', Blockly.JavaScript.ORDER_ATOMIC) || '90';
                return `await turnLeft(${angle});\n`;
            };

            Blockly.JavaScript['wait'] = function(block) {
                const time = Blockly.JavaScript.valueToCode(block, 'TIME', Blockly.JavaScript.ORDER_ATOMIC) || '1';
                return `await sleep(${time});\n`;
            };

            // Python 코드 생성기
            Blockly.Python['start'] = function(block) {
                return '# 프로그램 시작\n';
            };

            Blockly.Python['move_forward'] = function(block) {
                const distance = Blockly.Python.valueToCode(block, 'DISTANCE', Blockly.Python.ORDER_ATOMIC) || '10';
                return `move_forward(${distance})\n`;
            };

            Blockly.Python['turn_right'] = function(block) {
                const angle = Blockly.Python.valueToCode(block, 'ANGLE', Blockly.Python.ORDER_ATOMIC) || '90';
                return `turn_right(${angle})\n`;
            };

            Blockly.Python['turn_left'] = function(block) {
                const angle = Blockly.Python.valueToCode(block, 'ANGLE', Blockly.Python.ORDER_ATOMIC) || '90';
                return `turn_left(${angle})\n`;
            };

            Blockly.Python['wait'] = function(block) {
                const time = Blockly.Python.valueToCode(block, 'TIME', Blockly.Python.ORDER_ATOMIC) || '1';
                return `time.sleep(${time})\n`;
            };

            // 변수 관련 코드 생성기
            Blockly.JavaScript['variables_set'] = function(block) {
                const value = Blockly.JavaScript.valueToCode(block, 'VALUE', Blockly.JavaScript.ORDER_ASSIGNMENT) || '0';
                const varId = block.getFieldValue('VAR');
                const varName = block.workspace.getVariableById(varId).name;
                return `updateVariable("${varName}", ${value});\n`;
            };

            Blockly.JavaScript['variables_get'] = function(block) {
                const varId = block.getFieldValue('VAR');
                const varName = block.workspace.getVariableById(varId).name;
                return [`variables["${varName}"] || 0`, Blockly.JavaScript.ORDER_ATOMIC];
            };

            Blockly.JavaScript['math_change'] = function(block) {
                const delta = Blockly.JavaScript.valueToCode(block, 'DELTA', Blockly.JavaScript.ORDER_ADDITION) || '0';
                const varId = block.getFieldValue('VAR');
                const varName = block.workspace.getVariableById(varId).name;
                return `updateVariable("${varName}", (variables["${varName}"] || 0) + ${delta});\n`;
            };

            // Python 변수 관련 코드 생성기
            Blockly.Python['variables_set'] = function(block) {
                const value = Blockly.Python.valueToCode(block, 'VALUE', Blockly.Python.ORDER_ASSIGNMENT) || '0';
                const varId = block.getFieldValue('VAR');
                const varName = block.workspace.getVariableById(varId).name;
                return `${varName} = ${value}\n`;
            };

            Blockly.Python['variables_get'] = function(block) {
                const varId = block.getFieldValue('VAR');
                const varName = block.workspace.getVariableById(varId).name;
                return [varName, Blockly.Python.ORDER_ATOMIC];
            };

            Blockly.Python['math_change'] = function(block) {
                const delta = Blockly.Python.valueToCode(block, 'DELTA', Blockly.Python.ORDER_ADDITIVE) || '0';
                const varId = block.getFieldValue('VAR');
                const varName = block.workspace.getVariableById(varId).name;
                return `${varName} += ${delta}\n`;
            };

            // 조건문 코드 생성기
            Blockly.JavaScript['controls_if'] = function(block) {
                let n = 0;
                let code = '', branchCode, conditionCode;
                
                do {
                    conditionCode = Blockly.JavaScript.valueToCode(block, 'IF' + n, Blockly.JavaScript.ORDER_NONE) || 'false';
                    branchCode = Blockly.JavaScript.statementToCode(block, 'DO' + n);
                    
                    if (n == 0) {
                        code += 'if (' + conditionCode + ') {\n' + branchCode + '}';
                    } else {
                        code += ' else if (' + conditionCode + ') {\n' + branchCode + '}';
                    }
                    n++;
                } while (block.getInput('IF' + n));

                if (block.getInput('ELSE')) {
                    branchCode = Blockly.JavaScript.statementToCode(block, 'ELSE');
                    code += ' else {\n' + branchCode + '}';
                }
                
                return code + '\n';
            };

            Blockly.Python['controls_if'] = function(block) {
                let n = 0;
                let code = '', branchCode, conditionCode;
                
                do {
                    conditionCode = Blockly.Python.valueToCode(block, 'IF' + n, Blockly.Python.ORDER_NONE) || 'False';
                    branchCode = Blockly.Python.statementToCode(block, 'DO' + n) || Blockly.Python.PASS;
                    
                    if (n == 0) {
                        code += 'if ' + conditionCode + ':\n' + branchCode;
                    } else {
                        code += 'elif ' + conditionCode + ':\n' + branchCode;
                    }
                    n++;
                } while (block.getInput('IF' + n));

                if (block.getInput('ELSE')) {
                    branchCode = Blockly.Python.statementToCode(block, 'ELSE') || Blockly.Python.PASS;
                    code += 'else:\n' + branchCode;
                }
                
                return code;
            };

            // 논리 연산자 코드 생성기
            Blockly.JavaScript['logic_compare'] = function(block) {
                const OPERATORS = {
                    'EQ': '==',
                    'NEQ': '!=',
                    'LT': '<',
                    'LTE': '<=',
                    'GT': '>',
                    'GTE': '>='
                };
                const operator = OPERATORS[block.getFieldValue('OP')];
                const order = (operator == '==' || operator == '!=') ? 
                    Blockly.JavaScript.ORDER_EQUALITY : Blockly.JavaScript.ORDER_RELATIONAL;
                const argument0 = Blockly.JavaScript.valueToCode(block, 'A', order) || '0';
                const argument1 = Blockly.JavaScript.valueToCode(block, 'B', order) || '0';
                const code = argument0 + ' ' + operator + ' ' + argument1;
                return [code, order];
            };

            Blockly.Python['logic_compare'] = function(block) {
                const OPERATORS = {
                    'EQ': '==',
                    'NEQ': '!=',
                    'LT': '<',
                    'LTE': '<=',
                    'GT': '>',
                    'GTE': '>='
                };
                const operator = OPERATORS[block.getFieldValue('OP')];
                const order = (operator == '==' || operator == '!=') ? 
                    Blockly.Python.ORDER_EQUALITY : Blockly.Python.ORDER_RELATIONAL;
                const argument0 = Blockly.Python.valueToCode(block, 'A', order) || '0';
                const argument1 = Blockly.Python.valueToCode(block, 'B', order) || '0';
                const code = argument0 + ' ' + operator + ' ' + argument1;
                return [code, order];
            };

            // 논리 연산 (AND, OR)
            Blockly.JavaScript['logic_operation'] = function(block) {
                const operator = (block.getFieldValue('OP') == 'AND') ? '&&' : '||';
                const order = (operator == '&&') ? Blockly.JavaScript.ORDER_LOGICAL_AND : Blockly.JavaScript.ORDER_LOGICAL_OR;
                let argument0 = Blockly.JavaScript.valueToCode(block, 'A', order);
                let argument1 = Blockly.JavaScript.valueToCode(block, 'B', order);
                
                if (!argument0 && !argument1) {
                    argument0 = 'false';
                    argument1 = 'false';
                } else {
                    if (!argument0) argument0 = 'false';
                    if (!argument1) argument1 = 'false';
                }
                
                const code = argument0 + ' ' + operator + ' ' + argument1;
                return [code, order];
            };

            Blockly.Python['logic_operation'] = function(block) {
                const operator = (block.getFieldValue('OP') == 'AND') ? 'and' : 'or';
                const order = (operator == 'and') ? Blockly.Python.ORDER_LOGICAL_AND : Blockly.Python.ORDER_LOGICAL_OR;
                let argument0 = Blockly.Python.valueToCode(block, 'A', order);
                let argument1 = Blockly.Python.valueToCode(block, 'B', order);
                
                if (!argument0 && !argument1) {
                    argument0 = 'False';
                    argument1 = 'False';
                } else {
                    if (!argument0) argument0 = 'False';
                    if (!argument1) argument1 = 'False';
                }
                
                const code = argument0 + ' ' + operator + ' ' + argument1;
                return [code, order];
            };

            // 불린 값
            Blockly.JavaScript['logic_boolean'] = function(block) {
                const code = (block.getFieldValue('BOOL') == 'TRUE') ? 'true' : 'false';
                return [code, Blockly.JavaScript.ORDER_ATOMIC];
            };

            Blockly.Python['logic_boolean'] = function(block) {
                const code = (block.getFieldValue('BOOL') == 'TRUE') ? 'True' : 'False';
                return [code, Blockly.Python.ORDER_ATOMIC];
            };
        }

        // Blockly 워크스페이스 초기화
        function initializeBlockly() {
            try {
                console.log('Blockly 초기화 시작...');

                // 기존 워크스페이스 정리
                if (workspace) {
                    workspace.dispose();
                    workspace = null;
                }

                // Blockly 워크스페이스 생성
                workspace = Blockly.inject('blocklyDiv', {
                    toolbox: document.getElementById('toolboxXML'),
                    grid: {
                        spacing: 20,
                        length: 3,
                        colour: '#ccc',
                        snap: true
                    },
                    zoom: {
                        controls: true,
                        wheel: true,
                        startScale: 1.0,
                        maxScale: 3,
                        minScale: 0.3,
                        scaleSpeed: 1.2
                    },
                    trashcan: true,
                    sounds: false,
                    move: {
                        scrollbars: true,
                        drag: true,
                        wheel: true
                    },
                    renderer: 'zelos'
                });

                if (workspace) {
                    console.log('✅ Blockly 워크스페이스 생성 성공');
                    
                    // 워크스페이스 크기 조정
                    setTimeout(() => {
                        Blockly.svgResize(workspace);
                        console.log('워크스페이스 크기 조정 완료');
                    }, 100);

                    // 워크스페이스 변경 이벤트 리스너
                    workspace.addChangeListener(function(event) {
                        if (event.type === Blockly.Events.BLOCK_CREATE ||
                            event.type === Blockly.Events.BLOCK_DELETE ||
                            event.type === Blockly.Events.BLOCK_CHANGE ||
                            event.type === Blockly.Events.BLOCK_MOVE ||
                            event.type === Blockly.Events.VAR_CREATE ||
                            event.type === Blockly.Events.VAR_DELETE ||
                            event.type === Blockly.Events.VAR_RENAME) {
                            
                            console.log('워크스페이스 변경:', event.type);
                            updateCode();
                            updateBlockCount();
                            
                            // 변수 관련 이벤트 처리
                            if (event.type === Blockly.Events.VAR_CREATE || 
                                event.type === Blockly.Events.VAR_RENAME) {
                                const variableList = workspace.getAllVariables();
                                variableList.forEach(variable => {
                                    if (!(variable.name in variables)) {
                                        updateVariable(variable.name, 0);
                                    }
                                });
                            }
                        }
                    });

                    // 샘플 프로그램 로드
                    setTimeout(() => {
                        loadSampleProgram();
                        console.log('샘플 프로그램 로드 완료');
                    }, 200);

                } else {
                    console.error('❌ Blockly 워크스페이스 생성 실패');
                }

            } catch (error) {
                console.error('❌ Blockly 초기화 오류:', error);
            }
        }

        // 워크스페이스에 블록 추가 (수정된 버전)
        function addBlockToWorkspace(blockType) {
            console.log('워크스페이스에 블록 추가 시도:', blockType);
            
            if (!workspace) {
                console.error('❌ 워크스페이스가 초기화되지 않았습니다.');
                // 워크스페이스 재초기화 시도
                setTimeout(() => {
                    initializeBlockly();
                }, 100);
                return;
            }

            try {
                // 블록 생성
                const newBlock = workspace.newBlock(blockType);
                
                if (!newBlock) {
                    console.error('❌ 블록 생성 실패:', blockType);
                    return;
                }

                // 위치 설정 (겹치지 않도록)
                const existingBlocks = workspace.getAllBlocks();
                const x = 50 + (existingBlocks.length * 20);
                const y = 50 + (existingBlocks.length * 20);
                
                console.log('블록 위치 설정:', x, y);
                
                // 블록 초기화 및 렌더링
                newBlock.moveBy(x, y);
                newBlock.initSvg();
                newBlock.render();

                // 기본값 설정
                setupBlockDefaults(newBlock, blockType);

                // 변경 이벤트 발생
                Blockly.Events.fire(new Blockly.Events.BlockCreate(newBlock));
                
                console.log('✅ 블록 추가 성공:', blockType);
                
                // 즉시 코드 업데이트
                updateCode();
                updateBlockCount();
                
                // 성공 메시지
                logToConsole(`블록 "${blockType}"이 추가되었습니다.`);

            } catch (error) {
                console.error('❌ 블록 추가 오류:', error);
                logToConsole(`블록 추가 중 오류 발생: ${error.message}`);
            }
        }

        // 블록 기본값 설정 (개선된 버전)
        function setupBlockDefaults(block, blockType) {
            if (!block || !workspace) return;
            
            try {
                console.log('블록 기본값 설정:', blockType);
                
                switch (blockType) {
                    case 'move_forward':
                        if (block.getInput('DISTANCE') && block.getInput('DISTANCE').connection) {
                            const numberBlock = workspace.newBlock('math_number');
                            numberBlock.setFieldValue('10', 'NUM');
                            numberBlock.initSvg();
                            numberBlock.render();
                            block.getInput('DISTANCE').connection.connect(numberBlock.outputConnection);
                        }
                        break;
                    case 'turn_right':
                    case 'turn_left':
                        if (block.getInput('ANGLE') && block.getInput('ANGLE').connection) {
                            const numberBlock = workspace.newBlock('math_number');
                            numberBlock.setFieldValue('90', 'NUM');
                            numberBlock.initSvg();
                            numberBlock.render();
                            block.getInput('ANGLE').connection.connect(numberBlock.outputConnection);
                        }
                        break;
                    case 'wait':
                        if (block.getInput('TIME') && block.getInput('TIME').connection) {
                            const numberBlock = workspace.newBlock('math_number');
                            numberBlock.setFieldValue('1', 'NUM');
                            numberBlock.initSvg();
                            numberBlock.render();
                            block.getInput('TIME').connection.connect(numberBlock.outputConnection);
                        }
                        break;
                    case 'controls_repeat_ext':
                        if (block.getInput('TIMES') && block.getInput('TIMES').connection) {
                            const numberBlock = workspace.newBlock('math_number');
                            numberBlock.setFieldValue('10', 'NUM');
                            numberBlock.initSvg();
                            numberBlock.render();
                            block.getInput('TIMES').connection.connect(numberBlock.outputConnection);
                        }
                        break;
                    case 'variables_set':
                        // 변수 블록의 경우 변수 생성
                        if (workspace.getAllVariables().length === 0) {
                            workspace.createVariable('변수1');
                        }
                        break;
                    case 'math_change':
                        // 변수 변경 블록의 경우 변수 생성
                        if (workspace.getAllVariables().length === 0) {
                            workspace.createVariable('변수1');
                        }
                        break;
                }
                
                console.log('블록 기본값 설정 완료:', blockType);
            } catch (error) {
                console.error('블록 기본값 설정 오류:', error);
            }
        }

        // 기존 블록 팔레트 초기화 함수는 제거하고 위의 createSimpleBlockPalette로 대체

        // 기존 복잡한 블록 표시 함수들은 제거하고 위의 단순한 방식으로 대체

        // 블록 기본값 설정
        function setupBlockDefaults(block, blockType) {
            try {
                switch (blockType) {
                    case 'move_forward':
                        if (block.getInput('DISTANCE')) {
                            const numberBlock = workspace.newBlock('math_number');
                            numberBlock.setFieldValue('10', 'NUM');
                            numberBlock.initSvg();
                            numberBlock.render();
                            block.getInput('DISTANCE').connection.connect(numberBlock.outputConnection);
                        }
                        break;
                    case 'turn_right':
                    case 'turn_left':
                        if (block.getInput('ANGLE')) {
                            const numberBlock = workspace.newBlock('math_number');
                            numberBlock.setFieldValue('90', 'NUM');
                            numberBlock.initSvg();
                            numberBlock.render();
                            block.getInput('ANGLE').connection.connect(numberBlock.outputConnection);
                        }
                        break;
                    case 'wait':
                        if (block.getInput('TIME')) {
                            const numberBlock = workspace.newBlock('math_number');
                            numberBlock.setFieldValue('1', 'NUM');
                            numberBlock.initSvg();
                            numberBlock.render();
                            block.getInput('TIME').connection.connect(numberBlock.outputConnection);
                        }
                        break;
                    case 'controls_repeat_ext':
                        if (block.getInput('TIMES')) {
                            const numberBlock = workspace.newBlock('math_number');
                            numberBlock.setFieldValue('10', 'NUM');
                            numberBlock.initSvg();
                            numberBlock.render();
                            block.getInput('TIMES').connection.connect(numberBlock.outputConnection);
                        }
                        break;
                }
            } catch (error) {
                console.error('블록 기본값 설정 오류:', error);
            }
        }

        // 이벤트 리스너 설정
        function setupEventListeners() {
            console.log('이벤트 리스너 설정 중...');

            // 실행 버튼들
            const runButton = document.getElementById('runButton');
            const runButtonSmall = document.getElementById('runButtonSmall');
            
            if (runButton) {
                runButton.addEventListener('click', (e) => {
                    e.preventDefault();
                    runCode();
                });
            }
            
            if (runButtonSmall) {
                runButtonSmall.addEventListener('click', (e) => {
                    e.preventDefault();
                    runCode();
                });
            }
            
            // 제어 버튼들
            const stopButton = document.getElementById('stopButton');
            const resetButton = document.getElementById('resetButton');
            
            if (stopButton) {
                stopButton.addEventListener('click', (e) => {
                    e.preventDefault();
                    stopCode();
                });
            }
            
            if (resetButton) {
                resetButton.addEventListener('click', (e) => {
                    e.preventDefault();
                    resetCharacter();
                });
            }
            
            // 저장/로드 버튼들
            const saveButton = document.getElementById('saveButton');
            const loadButton = document.getElementById('loadButton');
            
            if (saveButton) {
                saveButton.addEventListener('click', (e) => {
                    e.preventDefault();
                    saveProgram();
                });
            }
            
            if (loadButton) {
                loadButton.addEventListener('click', (e) => {
                    e.preventDefault();
                    loadProgram();
                });
            }
            
            // 언어 전환 버튼들
            const pythonButton = document.getElementById('pythonButton');
            const javascriptButton = document.getElementById('javascriptButton');
            const cppButton = document.getElementById('cppButton');
            
            if (pythonButton) {
                pythonButton.addEventListener('click', (e) => {
                    e.preventDefault();
                    switchLanguage('python');
                });
            }
            
            if (javascriptButton) {
                javascriptButton.addEventListener('click', (e) => {
                    e.preventDefault();
                    switchLanguage('javascript');
                });
            }
            
            if (cppButton) {
                cppButton.addEventListener('click', (e) => {
                    e.preventDefault();
                    switchLanguage('cpp');
                });
            }
            
            // 창 크기 조정 이벤트
            window.addEventListener('resize', function() {
                if (workspace) {
                    Blockly.svgResize(workspace);
                }
            });
            
            // 키보드 단축키
            document.addEventListener('keydown', handleKeyboardShortcuts);
            
            // 페이지 이탈 경고
            window.addEventListener('beforeunload', function(e) {
                if (workspace && workspace.getAllBlocks(false).length > 0) {
                    e.preventDefault();
                    e.returnValue = '작업 중인 내용이 있습니다. 정말 페이지를 떠나시겠습니까?';
                }
            });

            console.log('모든 이벤트 리스너 설정 완료');
        }

        // 키보드 단축키 처리
        function handleKeyboardShortcuts(e) {
            if (e.ctrlKey || e.metaKey) {
                switch(e.key) {
                    case '1':
                        e.preventDefault();
                        if (navigationManager) navigationManager.navigateToDashboard();
                        break;
                    case 's':
                        e.preventDefault();
                        saveProgram();
                        break;
                    case 'o':
                        e.preventDefault();
                        loadProgram();
                        break;
                    case 'r':
                        e.preventDefault();
                        runCode();
                        break;
                }
            }
            
            if (e.key === 'Escape') {
                stopCode();
            }
        }

        // 간단한 샘플 프로그램 로드
        function loadSampleProgram() {
            if (!workspace) {
                console.log('워크스페이스가 없어서 샘플 프로그램을 나중에 로드합니다.');
                return;
            }

            try {
                console.log('간단한 샘플 프로그램 로드...');
                
                // 시작 블록
                const startBlock = workspace.newBlock('start');
                startBlock.moveBy(100, 100);
                startBlock.initSvg();
                startBlock.render();

                // 이동 블록
                const moveBlock = workspace.newBlock('move_forward');
                moveBlock.moveBy(100, 150);
                moveBlock.initSvg();
                moveBlock.render();

                // 숫자 블록
                const numberBlock = workspace.newBlock('math_number');
                numberBlock.setFieldValue('50', 'NUM');
                numberBlock.initSvg();
                numberBlock.render();

                // 연결
                if (moveBlock.getInput('DISTANCE') && numberBlock.outputConnection) {
                    moveBlock.getInput('DISTANCE').connection.connect(numberBlock.outputConnection);
                }

                // 블록 연결 (시작 -> 이동)
                if (startBlock.nextConnection && moveBlock.previousConnection) {
                    startBlock.nextConnection.connect(moveBlock.previousConnection);
                }

                console.log('✅ 샘플 프로그램 로드 완료');
                updateCode();
                updateBlockCount();
                logToConsole('샘플 프로그램이 로드되었습니다.');

            } catch (error) {
                console.error('샘플 프로그램 로드 오류:', error);
            }
        }

        // 코드 생성 및 업데이트
        function updateCode() {
            if (!workspace) return;

            try {
                const activeLanguage = document.querySelector('.language-button.active-language').id;
                let code = '';

                switch (activeLanguage) {
                    case 'pythonButton':
                        code = generatePythonCode();
                        break;
                    case 'javascriptButton':
                        code = generateJavaScriptCode();
                        break;
                    case 'cppButton':
                        code = generateCppCode();
                        break;
                    default:
                        code = generatePythonCode();
                }

                document.getElementById('codeContent').textContent = code;
            } catch (error) {
                console.error('코드 생성 오류:', error);
                document.getElementById('codeContent').textContent = '# 코드 생성 중 오류가 발생했습니다.\n# ' + error.message;
            }
        }

        // Python 코드 생성
        function generatePythonCode() {
            const pythonCode = Blockly.Python.workspaceToCode(workspace);
            const variableList = workspace.getAllVariables();
            
            let imports = 'import time\n\n';
            let functions = `def move_forward(distance):
    print(f"앞으로 {distance}만큼 이동")

def turn_right(angle):
    print(f"오른쪽으로 {angle}도 회전")

def turn_left(angle):
    print(f"왼쪽으로 {angle}도 회전")

def wait(seconds):
    time.sleep(seconds)

`;

            let mainFunction = 'def main():\n';
            
            // 변수 초기화
            if (variableList.length > 0) {
                mainFunction += '    # 변수 초기화\n';
                variableList.forEach(variable => {
                    mainFunction += `    ${variable.name} = 0\n`;
                });
                mainFunction += '\n';
            }
            
            // 생성된 코드 추가
            const indentedCode = pythonCode.split('\n')
                .map(line => line ? '    ' + line : '')
                .join('\n');
            
            mainFunction += '    # 프로그램 시작\n' + indentedCode;
            mainFunction += '\n\nif __name__ == "__main__":\n    main()';

            return imports + functions + mainFunction;
        }

        // JavaScript 코드 생성
        function generateJavaScriptCode() {
            const jsCode = Blockly.JavaScript.workspaceToCode(workspace);
            const variableList = workspace.getAllVariables();
            
            let code = `// 생성된 JavaScript 코드
const variables = {};

// 함수 정의
async function moveForward(distance) {
    console.log(\`앞으로 \${distance}만큼 이동\`);
    // 실제 움직임 구현
}

async function turnRight(angle) {
    console.log(\`오른쪽으로 \${angle}도 회전\`);
    // 실제 회전 구현
}

async function turnLeft(angle) {
    console.log(\`왼쪽으로 \${angle}도 회전\`);
    // 실제 회전 구현
}

async function sleep(seconds) {
    return new Promise(resolve => setTimeout(resolve, seconds * 1000));
}

function updateVariable(name, value) {
    variables[name] = value;
    console.log(\`변수 \${name}의 값이 \${value}로 변경됨\`);
}

// 메인 함수
async function main() {
`;

            // 변수 초기화
            if (variableList.length > 0) {
                code += '    // 변수 초기화\n';
                variableList.forEach(variable => {
                    code += `    updateVariable("${variable.name}", 0);\n`;
                });
                code += '\n';
            }

            // 생성된 코드 추가
            const indentedCode = jsCode.split('\n')
                .map(line => line ? '    ' + line : '')
                .join('\n');
            
            code += '    // 프로그램 시작\n' + indentedCode;
            code += '\n}\n\n// 실행\nmain().catch(console.error);';

            return code;
        }

        // C++ 코드 생성
        function generateCppCode() {
            const variableList = workspace.getAllVariables();
            
            let code = `// 생성된 C++ 코드
#include <iostream>
#include <chrono>
#include <thread>
#include <map>
#include <string>

using namespace std;

// 전역 변수
map<string, int> variables;

// 함수 정의
void moveForward(int distance) {
    cout << "앞으로 " << distance << "만큼 이동" << endl;
}

void turnRight(int angle) {
    cout << "오른쪽으로 " << angle << "도 회전" << endl;
}

void turnLeft(int angle) {
    cout << "왼쪽으로 " << angle << "도 회전" << endl;
}

void wait(double seconds) {
    this_thread::sleep_for(chrono::milliseconds((int)(seconds * 1000)));
}

void updateVariable(const string& name, int value) {
    variables[name] = value;
    cout << "변수 " << name << "의 값이 " << value << "로 변경됨" << endl;
}

int main() {
`;

            // 변수 초기화
            if (variableList.length > 0) {
                code += '    // 변수 초기화\n';
                variableList.forEach(variable => {
                    code += `    updateVariable("${variable.name}", 0);\n`;
                });
                code += '\n';
            }

            code += `    // 프로그램 시작
    // 여기에 블록에서 생성된 코드가 들어갑니다
    moveForward(60);
    for (int i = 0; i < 4; i++) {
        moveForward(60);
        turnRight(90);
        updateVariable("카운터", variables["카운터"] + 1);
        wait(0.5);
    }
    
    return 0;
}`;

            return code;
        }

        // 블록 개수 업데이트
        function updateBlockCount() {
            if (!workspace) return;
            const count = workspace.getAllBlocks(false).length;
            document.getElementById('blockCount').textContent = `블록 수: ${count}`;
        }

        // 캐릭터 리셋
        function resetCharacter() {
            x = 130;
            y = 130;
            angle = 0;
            variables = {};
            
            if (character) {
                character.style.left = x + 'px';
                character.style.top = y + 'px';
                character.style.transform = 'rotate(' + angle + 'deg)';
            }
            
            // 콘솔 초기화
            const consoleDiv = document.getElementById('console');
            consoleDiv.innerHTML = '<div class="console-line">> 프로그램 초기화 완료</div>';
            
            // 실행 상태 초기화
            isRunning = false;
            shouldStop = false;
            document.getElementById('executionStatus').textContent = '준비됨';
            
            updateVariableDisplay();
            logToConsole('캐릭터와 변수가 초기화되었습니다.');
        }

        // 변수 업데이트
        function updateVariable(name, value) {
            if (!isNaN(Number(value)) && value !== '') {
                value = Number(value);
            }
            variables[name] = value;
            updateVariableDisplay();
            logToConsole(`변수 ${name}: ${value}`);
        }

        // 변수 디스플레이 업데이트
        function updateVariableDisplay() {
            const variablesDiv = document.getElementById('variables');
            variablesDiv.innerHTML = '';

            // 사용자 정의 변수들
            for (const [name, value] of Object.entries(variables)) {
                const item = document.createElement('div');
                item.className = 'variable-item';
                item.textContent = `${name}: ${value}`;
                variablesDiv.appendChild(item);
            }

            // 위치 정보
            const posX = document.createElement('div');
            posX.className = 'variable-item';
            posX.textContent = `위치 X: ${Math.round(x)}`;
            variablesDiv.appendChild(posX);

            const posY = document.createElement('div');
            posY.className = 'variable-item';
            posY.textContent = `위치 Y: ${Math.round(y)}`;
            variablesDiv.appendChild(posY);

            const rotation = document.createElement('div');
            rotation.className = 'variable-item';
            rotation.textContent = `회전각: ${Math.round(angle)}°`;
            variablesDiv.appendChild(rotation);
        }

        // 콘솔에 로그 추가
        function logToConsole(message) {
            const consoleDiv = document.getElementById('console');
            const line = document.createElement('div');
            line.className = 'console-line';
            line.textContent = '> ' + message;
            consoleDiv.appendChild(line);
            consoleDiv.scrollTop = consoleDiv.scrollHeight;
        }

        // 움직임 함수들
        async function moveForward(distance) {
            logToConsole(`앞으로 ${distance}만큼 이동`);
            
            if (!character) return;
            
            const radians = angle * Math.PI / 180;
            const targetX = Math.max(10, Math.min(250, x + Math.sin(radians) * distance));
            const targetY = Math.max(10, Math.min(170, y - Math.cos(radians) * distance));
            
            const steps = Math.max(10, Math.abs(distance) / 2);
            const deltaX = (targetX - x) / steps;
            const deltaY = (targetY - y) / steps;
            
            for (let i = 0; i < steps && !shouldStop; i++) {
                x += deltaX;
                y += deltaY;
                character.style.left = x + 'px';
                character.style.top = y + 'px';
                updateVariableDisplay();
                await sleep(0.02);
            }
            
            x = targetX;
            y = targetY;
            character.style.left = x + 'px';
            character.style.top = y + 'px';
            updateVariableDisplay();
        }

        async function turnRight(degrees) {
            logToConsole(`오른쪽으로 ${degrees}도 회전`);
            
            if (!character) return;
            
            const targetAngle = angle + degrees;
            const steps = Math.max(5, Math.abs(degrees) / 10);
            const deltaAngle = degrees / steps;
            
            for (let i = 0; i < steps && !shouldStop; i++) {
                angle += deltaAngle;
                character.style.transform = `rotate(${angle}deg)`;
                updateVariableDisplay();
                await sleep(0.02);
            }
            
            angle = targetAngle % 360;
            character.style.transform = `rotate(${angle}deg)`;
            updateVariableDisplay();
        }

        async function turnLeft(degrees) {
            logToConsole(`왼쪽으로 ${degrees}도 회전`);
            
            if (!character) return;
            
            const targetAngle = angle - degrees;
            const steps = Math.max(5, Math.abs(degrees) / 10);
            const deltaAngle = degrees / steps;
            
            for (let i = 0; i < steps && !shouldStop; i++) {
                angle -= deltaAngle;
                character.style.transform = `rotate(${angle}deg)`;
                updateVariableDisplay();
                await sleep(0.02);
            }
            
            angle = targetAngle % 360;
            character.style.transform = `rotate(${angle}deg)`;
            updateVariableDisplay();
        }

        // 지연 함수
        function sleep(seconds) {
            return new Promise(resolve => setTimeout(resolve, seconds * 1000));
        }

        // 코드 실행
        async function runCode() {
            if (isRunning) {
                logToConsole('이미 실행 중입니다.');
                return;
            }

            if (!workspace) {
                logToConsole('워크스페이스가 초기화되지 않았습니다.');
                return;
            }

            const blocks = workspace.getAllBlocks(false);
            if (blocks.length === 0) {
                logToConsole('실행할 블록이 없습니다.');
                return;
            }

            isRunning = true;
            shouldStop = false;
            document.getElementById('executionStatus').textContent = '실행 중...';
            
            logToConsole('프로그램 실행 시작');

            try {
                // 변수 초기화
                const variableList = workspace.getAllVariables();
                variableList.forEach(variable => {
                    if (!(variable.name in variables)) {
                        variables[variable.name] = 0;
                    }
                });
                updateVariableDisplay();

                // 코드 생성 및 실행
                const code = Blockly.JavaScript.workspaceToCode(workspace);
                
                if (!code.trim()) {
                    logToConsole('생성된 코드가 없습니다.');
                    return;
                }

                // 안전한 코드 실행을 위한 함수 래핑
                const runFunction = new Function(
                    'moveForward', 'turnRight', 'turnLeft', 
                    'sleep', 'updateVariable', 'variables',
                    `return (async function() {
                        try {
                            ${code}
                        } catch (error) {
                            console.error("실행 오류:", error);
                            throw error;
                        }
                    })();`
                );

                await runFunction(
                    moveForward, turnRight, turnLeft,
                    sleep, updateVariable, variables
                );

                if (!shouldStop) {
                    logToConsole('프로그램 실행 완료');
                    document.getElementById('executionStatus').textContent = '완료';
                }
            } catch (error) {
                console.error('실행 오류:', error);
                logToConsole(`오류 발생: ${error.message}`);
                document.getElementById('executionStatus').textContent = '오류';
            } finally {
                isRunning = false;
                if (!shouldStop) {
                    setTimeout(() => {
                        document.getElementById('executionStatus').textContent = '준비됨';
                    }, 2000);
                }
            }
        }

        // 코드 실행 중지
        function stopCode() {
            if (!isRunning) {
                logToConsole('실행 중인 프로그램이 없습니다.');
                return;
            }
            
            shouldStop = true;
            logToConsole('프로그램 실행이 중지되었습니다.');
            document.getElementById('executionStatus').textContent = '중지됨';
            
            setTimeout(() => {
                isRunning = false;
                document.getElementById('executionStatus').textContent = '준비됨';
            }, 1000);
        }

        // 프로그램 저장
        function saveProgram() {
            if (!workspace) {
                logToConsole('워크스페이스가 초기화되지 않았습니다.');
                return;
            }

            try {
                const xml = Blockly.Xml.workspaceToDom(workspace);
                const xmlText = Blockly.Xml.domToText(xml);
                const projectName = document.getElementById('projectName').value || '내 프로젝트';
                
                localStorage.setItem('savedProgram', xmlText);
                localStorage.setItem('savedProjectName', projectName);

                const now = new Date();
                const timeString = now.toLocaleTimeString('ko-KR', { 
                    hour12: false, 
                    hour: '2-digit', 
                    minute: '2-digit' 
                });
                
                document.getElementById('lastSaved').textContent = `마지막 저장: ${timeString}`;
                logToConsole(`프로젝트 "${projectName}"이 저장되었습니다.`);
                
                if (navigationManager) {
                    navigationManager.showNotification('프로젝트가 저장되었습니다!');
                }
            } catch (error) {
                console.error('저장 오류:', error);
                logToConsole('저장 중 오류가 발생했습니다.');
                if (navigationManager) {
                    navigationManager.showNotification('저장 중 오류가 발생했습니다.', 'error');
                }
            }
        }

        // 프로그램 로드
        function loadProgram() {
            const savedProgram = localStorage.getItem('savedProgram');
            const savedProjectName = localStorage.getItem('savedProjectName');
            
            if (!savedProgram) {
                logToConsole('저장된 프로그램이 없습니다.');
                if (navigationManager) {
                    navigationManager.showNotification('저장된 프로젝트가 없습니다.', 'error');
                }
                return;
            }

            try {
                if (workspace) {
                    workspace.clear();
                    const xml = Blockly.Xml.textToDom(savedProgram);
                    Blockly.Xml.domToWorkspace(xml, workspace);
                    
                    if (savedProjectName) {
                        document.getElementById('projectName').value = savedProjectName;
                    }
                    
                    updateCode();
                    updateBlockCount();
                    logToConsole('저장된 프로그램을 불러왔습니다.');
                    
                    if (navigationManager) {
                        navigationManager.showNotification('프로젝트를 불러왔습니다!');
                    }
                }
            } catch (error) {
                console.error('로드 오류:', error);
                logToConsole('프로그램 로드 중 오류가 발생했습니다.');
                if (navigationManager) {
                    navigationManager.showNotification('프로젝트 로드 중 오류가 발생했습니다.', 'error');
                }
            }
        }

        // 언어 전환
        function switchLanguage(language) {
            const buttons = {
                python: document.getElementById('pythonButton'),
                javascript: document.getElementById('javascriptButton'),
                cpp: document.getElementById('cppButton')
            };
            
            const titles = {
                python: '생성된 코드 (Python)',
                javascript: '생성된 코드 (JavaScript)',
                cpp: '생성된 코드 (C++)'
            };

            // 모든 버튼을 비활성화
            Object.values(buttons).forEach(button => {
                button.className = 'language-button inactive-language';
            });

            // 선택된 버튼 활성화
            if (buttons[language]) {
                buttons[language].className = 'language-button active-language';
                document.querySelector('.code-title').textContent = titles[language];
                updateCode();
                logToConsole(`코드 언어가 ${language}로 변경되었습니다.`);
            }
        }
    </script>
</body>
</html>